---
title: "An Introduction to cleanr"
author: "Andreas Dominik Cullmann"
date: 2017-01-05, 11:43:15
bibliography: biblio.bib
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An Introduction to cleanr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
# The Intro to the Intro
Coding is an art, but most of the code we write is more or less dreadful.
Many tried to teach us how to write code less dreadful, be it implicitly as
@KR did,
be it explicitly as
@cc
did.

If you are concerned about your coding style, you will probably want to lint 
your codes with [lintr]( https://CRAN.R-project.org/package=lintr) or even 
reformat it using [formatR](https://CRAN.R-project.org/package=formatR).

This package tries to help you with your code`s layout:
it checks our code for files too long or wide, functions with too
many lines, too wide lines, too many arguments or too many levels of nesting.
Note that it's *not* a static code analyser like 
[lintr]( https://CRAN.R-project.org/package=lintr).

# A first example
```{r, echo = FALSE}
cleanr::set_cleanr_options(reset = TRUE)
```
You can use *cleanr* to check the layout of a file:
```{r}
path <- system.file("tests", "runit", "wrappers.r", package = "cleanr")
print(cleanr::check_file_layout(path))
```
Okay, looks good. Let's make it look worse.  

# Options
*cleanr* is controlled by a list of options named "cleanr". You can retrieve 
it either via ```options("cleanr")``` or via a convenience function:
```{r}
cleanr::get_cleanr_options(flatten_list = FALSE)
```

## Arguments to Check Functions
You can change any of those options on the fly (leaving the options set 
                                                untouched). 
The real life
```{r, eval = FALSE}
cleanr::check_file_layout(path, max_file_width = 79)
```
produces conditions that would stop this vignette from getting compiled, this is
why we here assert these conditions:

```{r}
print(tools::assertCondition(cleanr::check_file_layout(path, 
                                                     max_file_width = 79), 
                             c("cleanr", "error",  "condition"))
)
```
## Setting Options
You can set options using the convenience function:
```{r}
cleanr::set_cleanr_options(max_file_width = 75, 
                           max_file_length = 20)
```
```{r}
print(tools::assertCondition(cleanr::check_file_layout(path), 
                             c("cleanr", "error",  "condition"))
)
```

# Checking for File Layout
Files too long or too wide are hard to read.
You can check for a file's layout, i.e. for its lines' width and for the number 
of its lines.
You have already seen how to check for file layout:
```{r}
cleanr::set_cleanr_options(reset = TRUE)
path <- system.file("source", "R", "checks.R", package = "cleanr")
print(cleanr::check_file_layout(path)) 
```

We override some option by argument:
```{r}
print(tools::assertCondition(cleanr::check_file_layout(path, 
                                                       max_file_length = 100), 
                             c("cleanr", "error",  "condition"))
)
```


# Checking for Function Layout
Functions should

 - not have too many arguments,
 - not have too many levels of nesting,
 - neither have too many lines nor
 - have too many lines of code,
 - not have lines too wide and
 - explicitly return an object.

You can check all functions defined in a file:
```{r}
print(suppressWarnings(cleanr::check_functions_in_file(path)))
```
And again we override some option by argument:

```{r}
print(tools::assertCondition(suppressWarnings(cleanr::check_functions_in_file(path,
                                                                        max_num_arguments = 1)), 
                       c("cleanr", "error",  "condition"))
)
```

# Checking for File and Function Layout 
*cleanr* comes with wrappers to check for file and function layout in one go:
*check_file* runs the file and function layout checks on a file and 
*check_directory* runs them on all files (matching a given pattern) in a 
directory.
```{r}
print(suppressWarnings(cleanr::check_file(path)))
```

```{r}
path <- system.file("tests", "runit", package = "cleanr")
print(suppressWarnings(cleanr::check_directory(path,
                                               check_return = FALSE)))
```
To run *cleanr* on its own codes, we need to load its internal functions first:
```{r}
path <- system.file("source", "R", package = "cleanr")
cleanr::load_internal_functions("cleanr")
print(tools::assertCondition(suppressWarnings(cleanr::check_directory(path)), 
                       c("cleanr", "error",  "condition"))
)
```
# Disabling checks
To disable any check, set the corresponding option or argument to ```NULL``` or 
```FALSE```. 
```{r}
cleanr::set_cleanr_options(reset = TRUE)
cleanr::load_internal_functions("cleanr")
path <- system.file("source", "R", "wrappers.R", package = "cleanr")

# will produce a condition:
r <- tools::assertCondition(cleanr::check_functions_in_file(path, 
                                                            check_return = FALSE),
                            c("cleanr", "error",  "condition"))
print(r)
# set argument to disable the check causing the condition:
r <- cleanr::check_functions_in_file(path, check_return = FALSE, 
                                     max_num_arguments = FALSE)
print(r)
```



To completely disable all checks use:
```{r}
co <- get_cleanr_options(flatten_list = FALSE)
co <- lapply(co, function(x) x == FALSE)
options("cleanr" = list(cleanr = co))
get_cleanr_options() 
```
Now run on any directory, ```check_directory``` will always return ```TRUE```:
```{r}
path <- system.file("source", "R", package = "cleanr")
cleanr::load_internal_functions("cleanr")
print(cleanr::check_directory(path)) 
```




# References
